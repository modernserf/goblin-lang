export let [_true_ _false_] := native

export let Bool := [
  on {true} true
  on {false} false
]

# Option & Result in single value for mutual recursion
let OR := [
  on {some: value} [
    on {: do f}
      f{some: value}
    on {some!}
      value
    on {is some}
      true
    on {is none}
      false
    on {map: do f}
      OR{some: f{: value}}
    on {chain: do f}
      f{: value}
    on {or: default}
      value
    on {or do: do f}
      value
    on {=: other} other{:
      on {some: x} x = value
      on {none} false
    }
    on {!=: other}
      !(self = other)
    # 'dynamic' boolean logic, does not check other operand
    on {&&: other}
      other
    on {||: other}
      self
    # conversions
    on {to Option}
      self
    on {to Result}
      OR{ok: value}
  ]

  on {none} [
    on {: do f}
      f{none}
    # no {some!}
    on {is some}
      false
    on {is none}
      true
    on {map: do f}
      self
    on {chain: do f}
      self
    on {or: default}
      default
    on {or do: do f}
      f{}
    on {=: other} other{:
      on {some: x} false
      on {none} true
    }
    on {!=: other}
      !(self = other)
    on {&&: other}
      self
    on {||: other}
      other
    on {to Option}
      self
    on {to Result}
      OR{error: ()}
  ]
  
  on {ok: value} [
    on {: do f}
      f{ok: value}
    on {ok!}
      value
    # no {error!}
    on {is ok}
      true
    on {is error}
      false
    on {map: do f}
      OR{ok: f{: value}}
    on {map error: do f}
      self
    on {chain: do f}
      f{: value}
    on {chain error: do f}
      self
    on {ok or: default}
      value
    on {error or: default}
      default
    on {ok or do: do f}
      value
    on {error or do: do f}
      f{: value}
    on {=: other} other{:
      on {ok: x} x = value
      on {error: e} false
    }
    on {!=: other}
      !(self = other)
    on {&&: other}
      other
    on {||: other}
      self
    on {to Option}
      OR{some: value}
    on {to Result}
      self
  ]

  on {error: err} [
    on {: do f}
      f{error: err}
    # no {ok!}
    on {error!}
      err
    on {is ok}
      false
    on {is error}
      true
    on {map: do f}
      self
    on {map error: do f}
      OR{error: f{: err}}
    on {chain: do f}
      self
    on {chain error: do f}
      f{: err}
    on {ok or: default}
      default
    on {ok or do: do f}
      f{: err}
    on {error or: default}
      err
    on {error or do: do f}
      err
    on {=: other} other{:
      on {ok: x} false
      on {error: e} e = err
    }
    on {!=: other}
      !(self = other)
    on {&&: other}
      self
    on {||: other}
      other
    on {to Option}
      OR{none}
    on {to Result}
      self
  ]
]

export let Option := [
  on {} 
    OR{none}
  on {: value}
    OR{some: value}
  on {some: value}
    OR{some: value}
  on {none}
    OR{none}
]

export let Result := [
  on {: value}
    OR{ok: value}
  on {ok: value}
    OR{ok: value}
  on {error: err}
    OR{error: err}
]

export let Cell := [
  on {: value} 
    let instance := native{Cell}{: value}
    return [
      on {}
        instance{get}
      on {: next}
        instance{set: next}
        self
      on {->: do f}
        let prev := instance{get}
        let next := f{: prev}
        instance{set: next}
        self
    ]
]

export let Assert := native{Assert}

export let Array := native{Array}

export let Panic := native{Panic}

export let Control := [
  on {loop: do f}
    f{}
    self{loop: f}
]

let VecImpl := [
  on {_array_ _length_} 
    let private := [
      on {copy}
        VecImpl{
          array: array{from: 0 to: length} 
          length: length 
        }
      on {index: index}
        if index >= length then Panic{message: "index out of range"} end
        # TODO: handle negative index wraparound
        index
    ]
    return [
      on {length}
        length
      on {at: index}
        array{at: private{index: index}}
      on {at: index value: val}
        VecImpl{
          array: array{copy}{at: private{index: index} value: val} 
          length: length
        }
      on {,: val}
        {push: val}
        if array{length} = length then
          array{push: val}
          VecImpl{array: array length: length + 1}
        else
          private{copy}{push: val}
        end
      on {pop}
        let len := private{index: length - 1}
        # TODO: should periodically reallocate array so unused items can be GC'd
        return [
          most: VecImpl{array: array length: len}
          last: array{at: len}
        ]
      on {map: do f}
        var i := 0
        var out := Array{}
        Control{loop: {}
          if i >= length then 
            return VecImpl{array: out length: length}
          end
          let value := array{at: i}
          out{push: f{: value}}
          set i{+: 1}
        }
      on {filter: do f}
        var i := 0
        var out := Array{}
        Control{loop: {}
          if i >= length then 
            return VecImpl{array: out length: out{length}}
          end
          let value := array{at: i}
          if f{: array{at: i}} then
            out{push: value}
          end
          set i{+: 1}
        }
    ]
]

export let Vec := [
  on {}
    VecImpl{array: Array{} length: 0}
]

# - orderable objects respond to {order: other} with an Ord instance
# - operators (note: prefix!) can be used for quickly deriving relevant methods from {order: other}
# let Point := [
#   # ...
#   on {order: other}
#     let ord := x{order: other{x}}
#     if ord{!=} then return ord end
#     y{order: other{y}}
#   on {<: val}   <self{order: val}
#   on {<=: val} <=self{order: val}
#   on {=: val}   =self{order: val}
#   on {!=: val} !=self{order: val}
#   on {>=: val} >=self{order: val}
#   on {>: val}   >self{order: val}
# ]

export let Ord := [
  on {<} [
    on {: do f} f{<}
    on {<} true
    on {<=} true
    on {=} false
    on {!=} true
    on {>=} false
    on {>} false
  ]
  on {=} [
    on {: do f} f{=}
    on {<} false
    on {<=} true
    on {=} true
    on {!=} false
    on {>=} true
    on {>} false
  ]
  on {>} [
    on {: do f} f{=}
    on {<} false
    on {<=} false
    on {=} false
    on {!=} true
    on {>=} true
    on {>} true
  ]
]