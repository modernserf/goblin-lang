export let [_true_ _false_] := native

export let Bool := [
  on {true} true
  on {false} false
]


# - orderable objects respond to {order: other} with an Ord instance
# - operators (note: prefix!) can be used for quickly deriving relevant methods from {order: other}
export let Ord := [
  on {<} [
    on {: do f} f{<}
    on {<} true
    on {<=} true
    on {=} false
    on {!=} true
    on {>=} false
    on {>} false
  ]
  on {=} [
    on {: do f} f{=}
    on {<} false
    on {<=} true
    on {=} true
    on {!=} false
    on {>=} true
    on {>} false
  ]
  on {>} [
    on {: do f} f{=}
    on {<} false
    on {<=} false
    on {=} false
    on {!=} true
    on {>=} true
    on {>} true
  ]
]

# Option & Result in single value for mutual recursion
let OR := [
  on {some: value} [
    on {: do f}
      f{some: value}
    on {some!}
      value
    on {is some}
      true
    on {is none}
      false
    on {map: do f}
      OR{some: f{: value}}
    on {chain: do f}
      f{: value}
    on {or: default}
      value
    on {or do: do f}
      value
    on {=: other} other{:
      on {some: x} x = value
      else false
    }
    on {!=: other}
      !(self = other)
    # 'dynamic' boolean logic, does not check other operand
    on {&&: other}
      other
    on {||: other}
      self
    # conversions
    on {to Option}
      self
    on {to Result}
      OR{ok: value}
    # ordering {none} < any {some: value}
    on {order: other}
      other{:
        on {some: x}
          value{order: x}
        on {none}
          Ord{>}
      }
    on {<: val}   <self{order: val}
    on {<=: val} <=self{order: val}
    on {>=: val} >=self{order: val}
    on {>: val}   >self{order: val}
  ]

  on {none} [
    on {: do f}
      f{none}
    # no {some!}
    on {is some}
      false
    on {is none}
      true
    on {map: do f}
      self
    on {chain: do f}
      self
    on {or: default}
      default
    on {or do: do f}
      f{}
    on {=: other} other{:
      on {none} true
      else false
    }
    on {!=: other}
      !(self = other)
    on {&&: other}
      self
    on {||: other}
      other
    on {to Option}
      self
    on {to Result}
      OR{error: ()}
    on {order: other}
      other{:
        on {some: __}
          Ord{<}
        on {none}
          Ord{=}
      }
    on {<: val}   <self{order: val}
    on {<=: val} <=self{order: val}
    on {>=: val} >=self{order: val}
    on {>: val}   >self{order: val}
  ]
  
  on {ok: value} [
    on {: do f}
      f{ok: value}
    on {ok!}
      value
    # no {error!}
    on {is ok}
      true
    on {is error}
      false
    on {map: do f}
      OR{ok: f{: value}}
    on {map error: do f}
      self
    on {chain: do f}
      f{: value}
    on {chain error: do f}
      self
    on {ok or: default}
      value
    on {error or: default}
      default
    on {ok or do: do f}
      value
    on {error or do: do f}
      f{: value}
    on {=: other} other{:
      on {ok: x} x = value
      else false
    }
    on {!=: other}
      !(self = other)
    on {&&: other}
      other
    on {||: other}
      self
    on {to Option}
      OR{some: value}
    on {to Result}
      self
    # ordering any {error: err} < any {ok: value}
    on {order: other}
      other{:
        on {ok: x}
          value{order: x}
        on {error: __}
          Ord{>}
      }
    on {<: val}   <self{order: val}
    on {<=: val} <=self{order: val}
    on {>=: val} >=self{order: val}
    on {>: val}   >self{order: val}
  ]

  on {error: err} [
    on {: do f}
      f{error: err}
    # no {ok!}
    on {error!}
      err
    on {is ok}
      false
    on {is error}
      true
    on {map: do f}
      self
    on {map error: do f}
      OR{error: f{: err}}
    on {chain: do f}
      self
    on {chain error: do f}
      f{: err}
    on {ok or: default}
      default
    on {ok or do: do f}
      f{: err}
    on {error or: default}
      err
    on {error or do: do f}
      err
    on {=: other} other{:
      on {error: e} e = err
      else false
    }
    on {!=: other}
      !(self = other)
    on {&&: other}
      self
    on {||: other}
      other
    on {to Option}
      OR{none}
    on {to Result}
      self
    on {order: other}
      other{:
        on {ok: __}
          Ord{<}
        on {error: val}
          err{order: val}
      }
    on {<: val}   <self{order: val}
    on {<=: val} <=self{order: val}
    on {>=: val} >=self{order: val}
    on {>: val}   >self{order: val}
  ]
]

export let Option := [
  on {} 
    OR{none}
  on {: value}
    OR{some: value}
  on {some: value}
    OR{some: value}
  on {none}
    OR{none}
]

export let Result := [
  on {: value}
    OR{ok: value}
  on {ok: value}
    OR{ok: value}
  on {error: err}
    OR{error: err}
]

export let Cell := [
  on {: value} 
    let instance := native{Cell}{: value}
    return [
      on {}
        instance{get}
      on {: next}
        instance{set: next}
        self
      on {->: do f}
        let prev := instance{get}
        let next := f{: prev}
        instance{set: next}
        self
    ]
]

export let Assert := native{Assert}

export let Array := native{Array}

export let Panic := native{Panic}

export let Log := native{Log}

export let File := native{File}

let loop := native{loop}
export let Control := [
  on {loop: do f}
    loop{loop: f}
  on {times: times do: do f}
    var i := 0
    Control{loop: {}
      if i >= times then return end
      f{: i} ? f{}
      set i{+: 1}
    }
]

let VecImpl := [
  on {_array_ _length_} 
    let private := [
      on {copy}
        VecImpl{
          array: array{from: 0 to: length} 
          length: length 
        }
      on {index: index}
        if index >= length then Panic{message: "index out of range"} end
        # TODO: handle negative index wraparound
        index
      on {sort: arr by: do f lo: lo hi: hi}
        if (lo >= 0) && (hi >= 0) && (lo < hi) then
          let p := self{partition: arr by: f lo: lo hi: hi}
          self{sort: arr by: f lo: lo hi: p}
          self{sort: arr by: f lo: p + 1 hi: hi}
        end
      on {partition: arr by: do f lo: lo hi: hi}
        let pivot := arr{at: (hi + lo) >> 1}
        var left_idx := lo - 1 
        var right_idx := hi + 1
        Control{loop: {}
          private{
            inc: var left_idx 
            while: {: i} <f{left: arr{at: i} right: pivot}
          }
          private{
            dec: var right_idx
            while: {: i} >f{left: arr{at: i} right: pivot}
          }
          if left_idx >= right_idx then return right_idx end
          arr{at: left_idx swap: right_idx}
        }
      on {inc: var i while: do f}
        Control{loop: {}
          set i{+: 1}
          if !f{: i} then return end
        }
      on {dec: var i while: do f}
        Control{loop: {}
          set i{-: 1}
          if !f{: i} then return end
        }
    ]
    return [
      on {length}
        length
      on {at: index}
        array{at: private{index: index}}
      on {at: index value: val}
        VecImpl{
          array: array{copy}{at: private{index: index} value: val} 
          length: length
        }
      on {,: val}
        {push: val}
        if array{length} = length then
          array{push: val}
          VecImpl{array: array length: length + 1}
        else
          private{copy}{push: val}
        end
      on {pop}
        let len := private{index: length - 1}
        # TODO: should periodically reallocate array so unused items can be GC'd
        return [
          most: VecImpl{array: array length: len}
          last: array{at: len}
        ]
      on {map: do f}
        let out := Array{}
        Control{times: length do: {: i}
          let value := array{at: i}
          out{push: f{: value}}
        }
        VecImpl{array: out length: length}
      on {filter: do f}
        let out := Array{}
        Control{times: length do: {: i}
          let value := array{at: i}
          if f{: array{at: i}} then
            out{push: value}
          end
        }
        VecImpl{array: out length: out{length}}
      on {into: init fold: do f}
        var result := init
        Control{times: length do: {: i}
          let value := array{at: i}
          set result := f{: value into: result}
        }
        result
      on {=: other}
        let len := other{length} ? (return false)
        if len != length then return false end
        Control{times: length do: {: i}
          let val := other{at: i} ? (return false)
          if array{at: i} != val then return false end 
        }
        return true
      on {sort}
        self{sort: [asc]}
      on {sort: direction}
        self{sort: direction by key: {: x} x}
      on {sort by key: do f}
        self{sort: [asc] by key: f}
      on {sort: direction by key: do f}
        direction{:
          on {asc}
            self{sort by: {left: l right: r} f{:l}{order: f{: r}}}
          on {desc}
            self{sort by: {left: l right: r} f{:r}{order: f{: l}}}
        }
      on {sort by: do f}
        if length <= 1 then return self end
        let out := array{from: 0 to: length}
        private{sort: out by: f lo: 0 hi: length - 1}
        return VecImpl{array: out length: length}
    ]
]

export let Vec := [
  on {}
    VecImpl{array: Array{} length: 0}
  on {pop: var vec}
    let res := vec{pop}
    set vec := res{most}
    return res{last}
]
