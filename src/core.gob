export let Bool := [
  on {true} [
    on {: do f} 
      f{true}
    on {!} 
      Bool{false}
    # "bitwise" boolean logic
    # `other` must match with bool, always returns bool
    on {&: other} other{:
      on {true} Bool{true}
      on {false} Bool{false}
    }
    on {|: other} other{:
      on {true} Bool{true}
      on {false} Bool{true}
    }
    on {^: other} other{:
      on {true} Bool{false}
      on {false} Bool{true}
    }
    on {=: other} other{:
      on {true} Bool{true}
      on {false} Bool{false}
    }
    on {!=: other} other{:
      on {true} Bool{false}
      on {false} Bool{true}
    }
    on {then: t else: f}
      t
    on {then do: do t else do: do f}
      t{}
  ]
  on {false} [
    on {: do f} 
      f{false}
    on {!} 
      Bool{true}
    on {&: other} other{:
      on {true} Bool{false}
      on {false} Bool{false}
    }
    on {|: other} other{:
      on {true} Bool{true}
      on {false} Bool{false}
    }
    on {^: other} other{:
      on {true} Bool{true}
      on {false} Bool{false}
    }
    on {=: other} other{:
      on {true} Bool{false}
      on {false} Bool{true}
    }
    on {!=: other} other{:
      on {true} Bool{true}
      on {false} Bool{false}
    }
    on {then: t else: f}
      f
    on {then do: do t else do: do f}
      f{}
  ]
]

export let [_true_ _false_] := Bool

# Option & Result in single value for mutual recursion
let OR := [
  on {some: value} [
    on {: do f}
      f{some: value}
    on {some!}
      value
    on {is some}
      true
    on {is none}
      false
    on {map: do f}
      OR{some: f{: value}}
    on {chain: do f}
      f{: value}
    on {or: default}
      value
    on {or do: do f}
      value
    on {=: other} other{:
      on {some: x} x = value
      on {none} false
    }
    on {!=: other}
      !(self = other)
    # 'dynamic' boolean logic, does not check other operand
    on {&&: other}
      other
    on {||: other}
      self
    # conversions
    on {to Option}
      self
    on {to Result}
      OR{ok: value}
  ]

  on {none} [
    on {: do f}
      f{none}
    # no {some!}
    on {is some}
      false
    on {is none}
      true
    on {map: do f}
      self
    on {chain: do f}
      self
    on {or: default}
      default
    on {or do: do f}
      f{}
    on {=: other} other{:
      on {some: x} false
      on {none} true
    }
    on {!=: other}
      !(self = other)
    on {&&: other}
      self
    on {||: other}
      other
    on {to Option}
      self
    on {to Result}
      OR{error: ()}
  ]
  
  on {ok: value} [
    on {: do f}
      f{ok: value}
    on {ok!}
      value
    # no {error!}
    on {is ok}
      true
    on {is error}
      false
    on {map: do f}
      OR{ok: f{: value}}
    on {map error: do f}
      self
    on {chain: do f}
      f{: value}
    on {chain error: do f}
      self
    on {ok or: default}
      value
    on {error or: default}
      default
    on {ok or do: do f}
      value
    on {error or do: do f}
      f{: value}
    on {=: other} other{:
      on {ok: x} x = value
      on {error: e} false
    }
    on {!=: other}
      !(self = other)
    on {&&: other}
      other
    on {||: other}
      self
    on {to Option}
      OR{some: value}
    on {to Result}
      self
  ]

  on {error: err} [
    on {: do f}
      f{error: err}
    # no {ok!}
    on {error!}
      err
    on {is ok}
      false
    on {is error}
      true
    on {map: do f}
      self
    on {map error: do f}
      OR{error: f{: err}}
    on {chain: do f}
      self
    on {chain error: do f}
      f{: err}
    on {ok or: default}
      default
    on {ok or do: do f}
      f{: err}
    on {error or: default}
      err
    on {error or do: do f}
      err
    on {=: other} other{:
      on {ok: x} false
      on {error: e} e = err
    }
    on {!=: other}
      !(self = other)
    on {&&: other}
      self
    on {||: other}
      other
    on {to Option}
      OR{none}
    on {to Result}
      self
  ]
]

export let Option := [
  on {} 
    OR{none}
  on {: value}
    OR{some: value}
  on {some: value}
    OR{some: value}
  on {none}
    OR{none}
]

export let Result := [
  on {: value}
    OR{ok: value}
  on {ok: value}
    OR{ok: value}
  on {error: err}
    OR{error: err}
]

export let Cell := [
  on {: value} 
    let instance := native{Cell}{: value}
    return [
      on {}
        instance{get}
      on {: next}
        instance{set: next}
        self
      on {->: do f}
        let prev := instance{get}
        let next := f{: prev}
        instance{set: next}
        self
    ]
]

export let Assert := native{Assert}

export let Array := native{Array}