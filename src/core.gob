export let [_true_ _false_ String: string _debug_] := native

export let Debug := [
  on {: value} debug{: value}
]

export let Bool := [
  on {true} true
  on {false} false
]

export let String := [
  on {from char code: code}
    string{from char code: code}
  on {newline} 
    string{from char code: 10}
  on {tab} 
    string{from char code: 9}
]

# - orderable objects respond to {order: other} with an Ord instance
# - operators (note: prefix!) can be used for quickly deriving relevant methods from {order: other}
export let Ord := [
  on {<} [
    on {: do f} f{<}
    on {<} true
    on {<=} true
    on {=} false
    on {!=} true
    on {>=} false
    on {>} false
  ]
  on {=} [
    on {: do f} f{=}
    on {<} false
    on {<=} true
    on {=} true
    on {!=} false
    on {>=} true
    on {>} false
  ]
  on {>} [
    on {: do f} f{=}
    on {<} false
    on {<=} false
    on {=} false
    on {!=} true
    on {>=} true
    on {>} true
  ]
]

# Option & Result in single value for mutual recursion
let OR := [
  on {some: value} [
    on {: do f}
      f{some: value}
    on {some!}
      value
    on {is some}
      true
    on {is none}
      false
    on {map: do f}
      OR{some: f{: value}}
    on {chain: do f}
      f{: value}
    on {or: default}
      value
    on {or do: do f}
      value
    on {=: other} other{:
      on {some: x} x = value
      else false
    }
    on {!=: other}
      !(self = other)
    # 'dynamic' boolean logic, does not check other operand
    on {&&: other}
      other
    on {||: other}
      self
    # conversions
    on {to Option}
      self
    on {to Result}
      OR{ok: value}
    # ordering {none} < any {some: value}
    on {order: other}
      other{:
        on {some: x}
          value{order: x}
        on {none}
          Ord{>}
      }
    on {<: val}   <self{order: val}
    on {<=: val} <=self{order: val}
    on {>=: val} >=self{order: val}
    on {>: val}   >self{order: val}
  ]

  on {none} [
    on {: do f}
      f{none}
    # no {some!}
    on {is some}
      false
    on {is none}
      true
    on {map: do f}
      self
    on {chain: do f}
      self
    on {or: default}
      default
    on {or do: do f}
      f{}
    on {=: other} other{:
      on {none} true
      else false
    }
    on {!=: other}
      !(self = other)
    on {&&: other}
      self
    on {||: other}
      other
    on {to Option}
      self
    on {to Result}
      OR{error: ()}
    on {order: other}
      other{:
        on {some: __}
          Ord{<}
        on {none}
          Ord{=}
      }
    on {<: val}   <self{order: val}
    on {<=: val} <=self{order: val}
    on {>=: val} >=self{order: val}
    on {>: val}   >self{order: val}
  ]
  
  on {ok: value} [
    on {: do f}
      f{ok: value}
    on {ok!}
      value
    # no {error!}
    on {is ok}
      true
    on {is error}
      false
    on {map: do f}
      OR{ok: f{: value}}
    on {map error: do f}
      self
    on {chain: do f}
      f{: value}
    on {chain error: do f}
      self
    on {ok or: default}
      value
    on {error or: default}
      default
    on {ok or do: do f}
      value
    on {error or do: do f}
      f{: value}
    on {=: other} other{:
      on {ok: x} x = value
      else false
    }
    on {!=: other}
      !(self = other)
    on {&&: other}
      other
    on {||: other}
      self
    on {to Option}
      OR{some: value}
    on {to Result}
      self
    # ordering any {error: err} < any {ok: value}
    on {order: other}
      other{:
        on {ok: x}
          value{order: x}
        on {error: __}
          Ord{>}
      }
    on {<: val}   <self{order: val}
    on {<=: val} <=self{order: val}
    on {>=: val} >=self{order: val}
    on {>: val}   >self{order: val}
  ]

  on {error: err} [
    on {: do f}
      f{error: err}
    # no {ok!}
    on {error!}
      err
    on {is ok}
      false
    on {is error}
      true
    on {map: do f}
      self
    on {map error: do f}
      OR{error: f{: err}}
    on {chain: do f}
      self
    on {chain error: do f}
      f{: err}
    on {ok or: default}
      default
    on {ok or do: do f}
      f{: err}
    on {error or: default}
      err
    on {error or do: do f}
      err
    on {=: other} other{:
      on {error: e} e = err
      else false
    }
    on {!=: other}
      !(self = other)
    on {&&: other}
      self
    on {||: other}
      other
    on {to Option}
      OR{none}
    on {to Result}
      self
    on {order: other}
      other{:
        on {ok: __}
          Ord{<}
        on {error: val}
          err{order: val}
      }
    on {<: val}   <self{order: val}
    on {<=: val} <=self{order: val}
    on {>=: val} >=self{order: val}
    on {>: val}   >self{order: val}
  ]
]

export let Option := [
  on {} 
    OR{none}
  on {: value}
    OR{some: value}
  on {some: value}
    OR{some: value}
  on {none}
    OR{none}
]

export let Result := [
  on {: value}
    OR{ok: value}
  on {ok: value}
    OR{ok: value}
  on {error: err}
    OR{error: err}
]

export let Cell := [
  on {: value} 
    let instance := native{Cell}{: value}
    return [
      on {}
        instance{get}
      on {: next}
        instance{set: next}
        self
      on {->: do f}
        let prev := instance{get}
        let next := f{: prev}
        instance{set: next}
        self
    ]
]

export let Assert := native{Assert}

export let Array := native{Array}

export let Panic := native{Panic}

export let Log := native{Log}

export let File := native{File}

let loop := native{loop}
export let Control := [
  on {loop: do f}
    loop{loop: f}
  on {times: times do: do f}
    var i := 0
    Control{loop: {}
      if i >= times then return end
      f{: i} ? f{}
      set i{+: 1}
    }
]

let VecImpl := [
  on {_array_ _length_} 
    let private := [
      on {copy}
        VecImpl{
          array: array{from: 0 to: length} 
          length: length 
        }
      on {index: index}
        if index >= length then Panic{message: "index out of range"} end
        # TODO: handle negative index wraparound
        index
      on {sort: arr by: do f lo: lo hi: hi}
        if (lo >= 0) && (hi >= 0) && (lo < hi) then
          let p := self{partition: arr by: f lo: lo hi: hi}
          self{sort: arr by: f lo: lo hi: p}
          self{sort: arr by: f lo: p + 1 hi: hi}
        end
      on {partition: arr by: do f lo: lo hi: hi}
        let pivot := arr{at: (hi + lo) >> 1}
        var left_idx := lo - 1 
        var right_idx := hi + 1
        Control{loop: {}
          private{
            inc: var left_idx 
            while: {: i} <f{left: arr{at: i} right: pivot}
          }
          private{
            dec: var right_idx
            while: {: i} >f{left: arr{at: i} right: pivot}
          }
          if left_idx >= right_idx then return right_idx end
          arr{at: left_idx swap: right_idx}
        }
      on {inc: var i while: do f}
        Control{loop: {}
          set i{+: 1}
          if !f{: i} then return end
        }
      on {dec: var i while: do f}
        Control{loop: {}
          set i{-: 1}
          if !f{: i} then return end
        }
    ]
    return [
      on {length}
        length
      on {at: index}
        array{at: private{index: index}}
      on {at: index value: val}
        VecImpl{
          array: array{copy}{at: private{index: index} value: val} 
          length: length
        }
      on {,: val}
        {push: val}
        if array{length} = length then
          array{push: val}
          VecImpl{array: array length: length + 1}
        else
          private{copy}{push: val}
        end
      on {pop}
        let len := private{index: length - 1}
        # TODO: should periodically reallocate array so unused items can be GC'd
        return [
          most: VecImpl{array: array length: len}
          last: array{at: len}
        ]
      on {map: do f}
        let out := Array{}
        Control{times: length do: {: i}
          let value := array{at: i}
          out{push: f{: value} ? f{: value index: i}}
        }
        VecImpl{array: out length: length}
      on {filter: do f}
        let out := Array{}
        Control{times: length do: {: i}
          let value := array{at: i}
          if f{: array{at: i}} then
            out{push: value}
          end
        }
        VecImpl{array: out length: out{length}}
      on {find: do f}
        Control{times: length do: {: i}
          let value := array{at: i}
          if f{: array{at: i}} then
            return Option{some: value}
          end
          Option{none}
        }
      on {into: init fold: do f}
        var result := init
        Control{times: length do: {: i}
          let value := array{at: i}
          set result := f{: value into: result}
        }
        result
      on {=: other}
        let len := other{length} ? (return false)
        if len != length then return false end
        Control{times: length do: {: i}
          let val := other{at: i} ? (return false)
          if array{at: i} != val then return false end 
        }
        return true

      # slicing
      on {from: f to: t}
        let next := array{from: f to: t}
        let len := next{length}
        VecImpl{array: next length: len}
      on {from: f}
        self{from: f to: self{length}}
      on {to: t}
        self{from: 0 to: t}
      
      # sorting
      on {sort}
        self{sort: [asc]}
      on {sort: direction}
        self{sort: direction by key: {: x} x}
      on {sort by key: do f}
        self{sort: [asc] by key: f}
      on {sort: direction by key: do f}
        direction{:
          on {asc}
            self{sort by: {left: l right: r} f{:l}{order: f{: r}}}
          on {desc}
            self{sort by: {left: l right: r} f{:r}{order: f{: l}}}
        }
      on {sort by: do f}
        if length <= 1 then return self end
        let out := array{from: 0 to: length}
        private{sort: out by: f lo: 0 hi: length - 1}
        return VecImpl{array: out length: length}
    ]
]

export let Vec := [
  on {}
    VecImpl{array: Array{} length: 0}
  on {pop: var vec}
    let res := vec{pop}
    set vec := res{most}
    return res{last}
]

let HM := [
  on {empty}
    HM{entry: [empty] children: Option{none}}
  on {init children}
    var cs := Vec{}
    Control{times: 32 do: {}
      set cs{push: HM{empty}}
    }
    cs

  on {entry: entry children: children} [
    on {key: k hash: hash}
      entry{:
        on {empty} ()
        on {key: key value: value}
          if key = k then
            return Option{some: value}
          end
      }
      children{:
        on {some: children}
          let next := children{at: hash & 31}
          return next{key: k hash: hash >> 5}
        on {none}
          return Option{none}
      }

    on {entry: e hash: hash}
      entry{:
        on {empty}
          return HM{entry: e children: children}
        on {key: key value: value}
          if e{key} = key then
            return HM{entry: e children: children}
          end  
      }
      let cs := children{:
        on {none} HM{init children}
        on {some: cs} cs
      }
      let next := cs{at: hash & 31}
      let inserted := next{entry: e hash: hash >> 5}
      let next_cs := cs{at: hash & 31 value: inserted}
      HM{entry: entry children: Option{some: next_cs}}

    on {remove: k hash: hash}
      entry{:
        on {empty} ()
        on {key: key value: __}
          if k = key then
            return HM{entry: [empty] children: children}
          end
      }
      let cs := children{:
        on {none}
          return self
        on {some: cs}
          cs
      }
      let next := cs{at: hash & 31}
      let removed := next{remove: k hash: hash >> 5}
      let next_cs := cs{at: hash & 31 value: removed}
      HM{entry: entry children: Option{some: next_cs}}

    on {size}
      let this_node := entry{:
        on {empty} 0
        else 1
      }
      children{:
        on {none} this_node
        on {some: cs}
          cs{into: this_node fold: {: item into: sum}
            item{size} + sum
          }
      }
  ]
]

export let HashMap := [
  on {}
    HashMap{state: HM{empty}}
  on {state: state} [
    on {key: k}
      state{key: k hash: k{hash}}
    on {key: k value: v}
      let next_state := state{entry: [key: k value: v] hash: k{hash}}
      HashMap{state: next_state}
    on {remove: k}
      let next_state := state{remove: k hash: k{hash}}
      HashMap{state: next_state}
    on {size}
      state{size}
  ]
]

# TODO: three-state result - None | Ok(value) | Err(err) - instead of throwing
# (this will enable a try method for backtracking)
let ParseState := [
  on {source: src index: idx := 0} [
    on {peek}
      src{at: idx}
    on {next}
      ParseState{source: src index: idx + 1}
    on {done}
      idx >= src{length}
  ]
]

export let Parser := [
  on {parse: source with: parser}
    var state := ParseState{source: source}
    Parser{:parser}
      {skip: Parser{end}}
      {parse: var state}

  on {some: value} Parser{:[
    on {parse: var __}
      Option{some: value}
  ]}

  on {none} Parser{:[
    on {parse: var __}
      Option{none}
  ]}

  on {any} Parser{:[
    on {parse: var state}
      if state{done} then
        return Option{none}
      end
      let result := state{peek}
      set state{next}
      return Option{some: result}
  ]}

  on {end} Parser{:[
    on {parse: var state}
      if state{done} then
        Option{some: ()}
      else
        Option{none}
      end
  ]}

  on {match: f} Parser{:[
    on {parse: var state}
      let result := state{peek}
      if f{: result} then
        set state{next}
        Option{some: result}
      else
        Option{none}
      end
  ]}

  on {token: tok}
    Parser{match: [=: tok]}

  on {digit} Parser{:[
    on {parse: var state}
      let ch := state{peek}
      let code := ch{code at: 0}
      let int := code - 48 # ASCII '0'
      if (int < 0) || (int > 9) then
        return Option{none}
      end
      set state{next}
      Option{some: int}
  ]}

  on {integer} 
    +Parser{digit} |>> [{: digits}
      digits{into: 0 fold: {: digit into: num}
        (num * 10) + digit
      }
    ]

  on {newline}
    Parser{token: String{newline}} 
  
  # combinator utils
  on {: parser} [
    on {parse: var state}
      parser{parse: var state}

    on {|>>: f}
      {apply: f} Parser{:[
      on {parse: var state}
        parser{parse: var state}{map: f}
    ]}

    on {some!} Parser{:[
      on {parse: var state}
        self{parse: var state}{some!}
    ]}

    on {>>%: constant}
      {constant: constant}
      self |>> [{: __} constant]

    on {.>>.: next_parser} 
      {pair: next_parser} Parser{:[
        on {parse: var state}
          let first := parser{parse: var state}{some!} ? (return Option{none})
          let second := next_parser{parse: var state}{some!}
          Option{some: [0: first 1: second]}
      ]}

    on {.>>: next_parser}
      {skip: next_parser}
        self .>>. next_parser |>> [0]

    on {>>.: next_parser}
      {then: next_parser}
        self .>>. next_parser |>> [1]

    on {between: open_parser and: close_parser}
      Parser{:open_parser} >>. self .>> close_parser
   
    on 
      {repeat: min} Parser{:[
      on {parse: var state}
        # save previous state for backtracking
        let prev_state := state
        var result := Vec{}
        Control{loop: {}
          let item := parser{parse: var state}{:
            on {some: x} x
            on {none}
              if result{length} < min then
                set state := prev_state
                return Option{none}
              end
              return Option{some: result}
          }
          set result{push: item}
        }
    ]}
    on {+} {repeat1}
      self{repeat: 1}
    on {*} {repeat}
      self{repeat: 0}
    on {opt} {optional} Parser{:[
      on {parse: var state}
        let res := parser{parse: var state}
        Option{some: res}
    ]}
  ]
]
