import [_Option_ _Vec_ _String_ _Control_] := "core"

# TODO: three-state result - None | Ok(value) | Err(err) - instead of throwing
# (this will enable a try method for backtracking)
let ParseState := [
  on {source: src index: idx := 0} [
    on {peek}
      src{at: idx}
    on {next}
      ParseState{source: src index: idx + 1}
    on {done}
      idx >= src{length}
  ]
]

export let Parser := [
  on {parse: source with: parser}
    var state := ParseState{source: source}
    parser
      {skip: Parser{end}}
      {parse: var state}

  on {some: value} Parser{:[
    on {parse: var __}
      Option{some: value}
  ]}

  on {none} Parser{:[
    on {parse: var __}
      Option{none}
  ]}

  on {any} Parser{:[
    on {parse: var state}
      if state{done} then
        return Option{none}
      end
      let result := state{peek}
      set state{next}
      return Option{some: result}
  ]}

  on {end} Parser{:[
    on {parse: var state}
      if state{done} then
        Option{some: ()}
      else
        Option{none}
      end
  ]}

  on {match: f} Parser{:[
    on {parse: var state}
      let result := state{peek}
      if f{: result} then
        set state{next}
        Option{some: result}
      else
        Option{none}
      end
  ]}

  on {try match: f} Parser{:[
    on {parse: var state}
      let result := state{peek}
      f{: result}{map: {: value}
        set state{next}
        value
      }
  ]}

  on {token: tok}
    Parser{match: [=: tok]}

  on {digit} Parser{:[
    on {parse: var state}
      let ch := state{peek}
      let code := ch{code at: 0}
      let int := code - 48 # ASCII '0'
      if (int < 0) || (int > 9) then
        return Option{none}
      end
      set state{next}
      Option{some: int}
  ]}

  on {integer} 
    +Parser{digit} |>> [{: digits}
      digits{into: 0 fold: {: digit into: num}
        (num * 10) + digit
      }
    ]
  
  on {range: a through: b} Parser{:[
    on {parse: var state}
      let ch := state{peek}
      let code := ch{code at: 0}
      if (code >= a{code at: 0}) && (code <= b{code at: 0}) then
        set state{next}
        Option{some: ch}
      else
        Option{none}
      end
  ]}

  on {newline}
    Parser{token: String{newline}} 
  
  # combinator utils
  on {: parser} [
    on {parse: var state}
      parser{parse: var state}

    on {|>>: f}
      {apply: f} Parser{:[
      on {parse: var state}
        parser{parse: var state}{map: f}
    ]}

    on {some!} Parser{:[
      on {parse: var state}
        self{parse: var state}{some!}
    ]}

    on {>>%: constant}
      {constant: constant}
      self |>> [{: __} constant]

    on {.>>.: next_parser} 
      {pair: next_parser} Parser{:[
      on {parse: var state}
        let first := parser{parse: var state}{some!} ? (return Option{none})
        let second := next_parser{parse: var state}{some!}
        Option{some: [0: first 1: second]}
    ]}

    on {.>>: next_parser}
      {skip: next_parser}
      self .>>. next_parser |>> [0]

    on {>>.: next_parser}
      {then: next_parser}
      self .>>. next_parser |>> [1]

    on {|: next_parser} 
      {or: next_parser} Parser{:[
        on {parse: var state}
          parser{parse: var state}
            {or chain: {} next_parser{parse: var state}}
    ]}

    on {between: open_parser and: close_parser}
      open_parser >>. self .>> close_parser
   
    on {repeat: min} Parser{:[
      on {parse: var state}
        # save previous state for backtracking
        let prev_state := state
        var result := Vec{}
        Control{loop: {}
          let item := parser{parse: var state}{:
            on {some: x} x
            on {none}
              if result{length} < min then
                set state := prev_state
                return Option{none}
              end
              return Option{some: result}
          }
          set result{push: item}
        }
    ]}
    on {+} {repeat1}
      self{repeat: 1}
    on {*} {repeat}
      self{repeat: 0}
    on {opt} {optional} Parser{:[
      on {parse: var state}
        let res := parser{parse: var state}
        Option{some: res}
    ]}
  ]
]
