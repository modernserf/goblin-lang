export let [_true_ _false_ String: string _debug_] := native

export let Debug := [
  on {: value} debug{: value}
]

export let Bool := [
  on {true} true
  on {false} false
]

export let String := [
  on {from char code: code}
    string{from char code: code}
  on {newline} 
    string{from char code: 10}
  on {tab} 
    string{from char code: 9}
]

# - orderable objects respond to {order: other} with an Ord instance
# - operators (note: prefix!) can be used for quickly deriving relevant methods from {order: other}
export let Ord := [
  on {<} [
    on {: do f} f{<}
    on {<} true
    on {<=} true
    on {=} false
    on {!=} true
    on {>=} false
    on {>} false
  ]
  on {=} [
    on {: do f} f{=}
    on {<} false
    on {<=} true
    on {=} true
    on {!=} false
    on {>=} true
    on {>} false
  ]
  on {>} [
    on {: do f} f{=}
    on {<} false
    on {<=} false
    on {=} false
    on {!=} true
    on {>=} true
    on {>} true
  ]
]


# Option & Result in single value for mutual recursion
let OR := [
  on {some: value} [
    on {: do f}
      f{some: value}
    on {some!}
      value
    on {is some}
      true
    on {is none}
      false
    on {map: do f}
      OR{some: f{: value}}
    on {chain: do f}
      f{: value}
    on {chain none: do f}
      self
    on {or: default}
      value
    on {or do: do f}
      value
    on {=: other} other{:
      on {some: x} x = value
      else false
    }
    on {!=: other}
      !(self = other)
    # 'dynamic' boolean logic, does not check other operand
    on {&&: other}
      other
    on {||: other}
      self
    # conversions
    on {to Option}
      self
    on {to Result}
      OR{ok: value}
    # ordering {none} < any {some: value}
    on {order: other}
      other{:
        on {some: x}
          value{order: x}
        on {none}
          Ord{>}
      }
    on {<: val}   <self{order: val}
    on {<=: val} <=self{order: val}
    on {>=: val} >=self{order: val}
    on {>: val}   >self{order: val}
  ]

  on {none} [
    on {: do f}
      f{none}
    # no {some!}
    on {is some}
      false
    on {is none}
      true
    on {map: do f}
      self
    on {chain: do f}
      self
    on {chain none: do f}
      f{}
    on {or: default}
      default
    on {or do: do f}
      f{}
    on {=: other} other{:
      on {none} true
      else false
    }
    on {!=: other}
      !(self = other)
    on {&&: other}
      self
    on {||: other}
      other
    on {to Option}
      self
    on {to Result}
      OR{error: ()}
    on {order: other}
      other{:
        on {some: __}
          Ord{<}
        on {none}
          Ord{=}
      }
    on {<: val}   <self{order: val}
    on {<=: val} <=self{order: val}
    on {>=: val} >=self{order: val}
    on {>: val}   >self{order: val}
  ]
  
  on {ok: value} [
    on {: do f}
      f{ok: value}
    on {ok!}
      value
    # no {error!}
    on {is ok}
      true
    on {is error}
      false
    on {map: do f}
      OR{ok: f{: value}}
    on {map error: do f}
      self
    on {chain: do f}
      f{: value}
    on {chain error: do f}
      self
    on {ok or: default}
      value
    on {error or: default}
      default
    on {ok or do: do f}
      value
    on {error or do: do f}
      f{: value}
    on {=: other} other{:
      on {ok: x} x = value
      else false
    }
    on {!=: other}
      !(self = other)
    on {&&: other}
      other
    on {||: other}
      self
    on {to Option}
      OR{some: value}
    on {to Result}
      self
    # ordering any {error: err} < any {ok: value}
    on {order: other}
      other{:
        on {ok: x}
          value{order: x}
        on {error: __}
          Ord{>}
      }
    on {<: val}   <self{order: val}
    on {<=: val} <=self{order: val}
    on {>=: val} >=self{order: val}
    on {>: val}   >self{order: val}
  ]

  on {error: err} [
    on {: do f}
      f{error: err}
    # no {ok!}
    on {error!}
      err
    on {is ok}
      false
    on {is error}
      true
    on {map: do f}
      self
    on {map error: do f}
      OR{error: f{: err}}
    on {chain: do f}
      self
    on {chain error: do f}
      f{: err}
    on {ok or: default}
      default
    on {ok or do: do f}
      f{: err}
    on {error or: default}
      err
    on {error or do: do f}
      err
    on {=: other} other{:
      on {error: e} e = err
      else false
    }
    on {!=: other}
      !(self = other)
    on {&&: other}
      self
    on {||: other}
      other
    on {to Option}
      OR{none}
    on {to Result}
      self
    on {order: other}
      other{:
        on {ok: __}
          Ord{<}
        on {error: val}
          err{order: val}
      }
    on {<: val}   <self{order: val}
    on {<=: val} <=self{order: val}
    on {>=: val} >=self{order: val}
    on {>: val}   >self{order: val}
  ]
]

export let Option := [
  on {} 
    OR{none}
  on {: value}
    OR{some: value}
  on {some: value}
    OR{some: value}
  on {none}
    OR{none}
]

export let Result := [
  on {: value}
    OR{ok: value}
  on {ok: value}
    OR{ok: value}
  on {error: err}
    OR{error: err}
]

export let Cell := [
  on {: value} 
    let instance := native{Cell}{: value}
    return [
      on {}
        instance{get}
      on {: next}
        instance{set: next}
        self
      on {->: do f}
        let prev := instance{get}
        let next := f{: prev}
        instance{set: next}
        self
    ]
]

export let Assert := native{Assert}

export let Array := native{Array}

export let Panic := native{Panic}

export let Log := native{Log}

export let File := native{File}

let loop := native{loop}
export let Control := [
  on {loop: do f}
    loop{loop: f}
  on {times: times do: do f}
    var i := 0
    Control{loop: {}
      if i >= times then return end
      f{: i} ? f{}
      set i{+: 1}
    }
]

let Iter := [
  # instance
  on {: iterable} [
    on {next}
      iterable{next}{:
        on {value: value next: next}
          [value: value next: Iter{: next}]
        on {done}
          [done]
      }
    # eager handlers: produce a result, run immediately, can take do blocks
    on {each: do f}
      var state := iterable
      Control{loop: {}
        state{next}{:
          on {value: value next: next} 
            f{:value}
            set state := next
          on {done} return self
        }
      }
    on {into: init_state fold: do f}
      var state := init_state
      self{each: {: value}
        set state := f{: value into: state}
      }
      state
    on {enumerate}
      let indexes := self{into: -1 scan: [{: __ into: i} i + 1]}
      Iter{value: [index: () value: ()]}
        {into: [index] join: indexes}
        {into: [value] join: self}
    on {last}
      var last := Option{none}
      self{each: {: value} 
        set last := Option{some:value}
      }
      last
    on {count}
      var count := 0
      self{each: {: __} 
        set count{+: 1}
      }
      count
    on {nth: start_index}
      var index := 0
      self{each: {: value}
        if index = start_index then return Option{some: value} end
        set index{+: 1}
      }
      return Option{none}
    on {any: do f}
      self{each: {: value}
        if f{: value} then return true end
      }
      return false
    on {every: do f}
      self{each: {: value}
        if !f{: value} then return false end
      }
      return true
    on {find: do f}
      self{each: {: value}
        if f{: value} then return Option{some: value} end
      }
      return Option{none}
    on {find index: do f}
      self{enumerate}{each: {: [index: i value: v]}
        if f{: v} then return Option{some: i} end
      }
      return Option{none}
    # lazy handlers: produce an iterator
    on {map: f} Iter{:[
      on {next} iterable{next}{:
        on {value: value next: next}
          [value: f{: value} next: next{map: f}]
        on {done}
          [done]
      }
    ]}
    on {filter: f} Iter{:[
      on {next}
        var current := iterable
        Control{loop: {}
          current{next}{:
            on {value: value next: next}
              if f{: value} then
                return [value: value next: next{filter: f}]
              else
                set current := next{filter: f}
              end
            on {done}
              return [done]
          }
        }
    ]}
    on {filter map: f} Iter{:[
      on {next} 
        var current := iterable
        Control{loop: {}
          current{next}{:
            on {value: value next: next}
              f{: value}{:
                on {some: result}
                  return [value: result next: next{filter map: f}]
                on {none}
                  set current := next{filter map: f}
              }
            on {done}
              return [done]
          }
        }
    ]}
    on {,: item} {push: item} Iter{:[
      on {next}
        iterable{next}{:
          on {value: value next: next}
            [value: value next: next{push: item}]
          on {done}
            [value: item next: Iter{}]
        }
    ]}
    on {++: other} {append: other} Iter{:[
      on {next}
        iterable{next}{:
          on {value: value next: next}
            [value: value next: next{append: other}]
          on {done}
            other{next}
        }
    ]}
    on {chain: f} Iter{:[
      on {next}
        iterable{next}{:
          on {value: value next: next}
            f{: value}{append: next}{next}
          on {done}
            [done]
        }
    ]}
    # cycle has init & running states, so that empty iterators do not infinite loop
    on {cycle} Iter{:[
      on {next}
        iterable{next}{:
          on {value: value next: next}
            [value: value next: next{cycle: iterable}]
          on {done}
            [done]
        }
    ]}
    on {cycle: state} Iter{:[
      on {next}
        iterable{next}{:
          on {value: value next: next}
            [value: value next: next{cycle: state}]
          on {done}
            state{cycle}{next}
        }
    ]}
    on {pair: other} Iter{:[
      on {next}
        [0: iterable{next} 1: other{next}]{:
          on {0: [value: v0 next: next0] 1: [value: v1 next: next1]}
            [value: [0: v0 1: v1] next: next0{pair: next1}]
          else
            [done]
        }
    ]}
    on {into: f join: other} Iter{:[
      on {next}
        [0: iterable{next} 1: other{next}]{:
          on {0: [value: v0 next: next0] 1: [value: v1 next: next1]}
            [value: f{: v1 into: v0} next: next0{into: f join: next1}]
          else
            [done]
        }
    ]}
    on {into: state scan: f} Iter{:[
      on {next}
        iterable{next}{:
          on {value: value next: next}
            let next_state := f{: value into: state}
            [value: next_state next: next{into: next_state scan: f}]
          on {done}
            [done]
        }
    ]}
    on {take while: f} Iter{:[
      on {next}
        iterable{next}{:
          on {value: value next: next}
            if f{:value} then [value: value next: next]
            else [done] end
          on {done}[done]
        }
    ]}
    on {drop while: f} Iter{:[
      on {next}
        var current := iterable
        Control{loop: {}
          current{next}{:
            on {value: value next: next}
              if !f{:value} then return [value: value next: next] end
            on {done}
              return [done]
          }
        }
    ]}
    on {take: count}
      iterable
        {enumerate}
        {take while: [{: p} p{index} <= count]}
        {map: [value]}

    on {drop: count}
      iterable
        {enumerate}
        {drop while: [{: p} p{index} <= count]}
        {map: [value]}
  ]
  # additional constructors
  # no items
  on {} Iter{:[
    on {next}
      [done]
  ]}
  # repeats the same item, used as applicative base
  on {value: value} Iter{: [
    on {next}
      [value: value next: Iter{value: value}]
  ]}
]

let VecImpl := [
  on {_array_ _length_} 
    let private := [
      on {copy}
        VecImpl{
          array: array{from: 0 to: length} 
          length: length 
        }
      on {index: index}
        if index >= length then Panic{message: "index out of range"} end
        # TODO: handle negative index wraparound
        index
      on {sort: arr by: do f lo: lo hi: hi}
        if (lo >= 0) && (hi >= 0) && (lo < hi) then
          let p := self{partition: arr by: f lo: lo hi: hi}
          self{sort: arr by: f lo: lo hi: p}
          self{sort: arr by: f lo: p + 1 hi: hi}
        end
      on {partition: arr by: do f lo: lo hi: hi}
        let pivot := arr{at: (hi + lo) >> 1}
        var left_idx := lo - 1 
        var right_idx := hi + 1
        Control{loop: {}
          private{
            inc: var left_idx 
            while: {: i} <f{left: arr{at: i} right: pivot}
          }
          private{
            dec: var right_idx
            while: {: i} >f{left: arr{at: i} right: pivot}
          }
          if left_idx >= right_idx then return right_idx end
          arr{at: left_idx swap: right_idx}
        }
      on {inc: var i while: do f}
        Control{loop: {}
          set i{+: 1}
          if !f{: i} then return end
        }
      on {dec: var i while: do f}
        Control{loop: {}
          set i{-: 1}
          if !f{: i} then return end
        }
    ]
    return [
      on {length}
        length
      on {at: index}
        array{at: private{index: index}}
      on {at: index value: val}
        VecImpl{
          array: array{copy}{at: private{index: index} value: val} 
          length: length
        }
      on {,: val}
        {push: val}
        if array{length} = length then
          array{push: val}
          VecImpl{array: array length: length + 1}
        else
          private{copy}{push: val}
        end
      on {pop}
        let len := private{index: length - 1}
        # TODO: should periodically reallocate array so unused items can be GC'd
        return [
          most: VecImpl{array: array length: len}
          last: array{at: len}
        ]
      on {map: do f}
        let out := Array{}
        Control{times: length do: {: i}
          let value := array{at: i}
          out{push: f{: value} ? f{: value index: i}}
        }
        VecImpl{array: out length: length}
      on {filter: do f}
        let out := Array{}
        Control{times: length do: {: i}
          let value := array{at: i}
          if f{: array{at: i}} then
            out{push: value}
          end
        }
        VecImpl{array: out length: out{length}}
      on {find: do f}
        Control{times: length do: {: i}
          let value := array{at: i}
          if f{: array{at: i}} then
            return Option{some: value}
          end
          Option{none}
        }
      on {into: init fold: do f}
        var result := init
        Control{times: length do: {: i}
          let value := array{at: i}
          set result := f{: value into: result}
        }
        result
      on {sum}
        var result := 0
        Control{times: length do: {: i}
          set result{+: array{at: i}}
        }
        result

      on {=: other}
        let len := other{length} ? (return false)
        if len != length then return false end
        Control{times: length do: {: i}
          let val := other{at: i} ? (return false)
          if array{at: i} != val then return false end 
        }
        return true

      # slicing
      on {from: f to: t}
        let next := array{from: f to: t}
        let len := next{length}
        VecImpl{array: next length: len}
      on {from: f}
        self{from: f to: self{length}}
      on {to: t}
        self{from: 0 to: t}

      on {++: other}
        {append: other}
        var next := self
        Control{times: other{length} do: {: i}
          set next{push: other{at: i}}
        }
        next
      
      # sorting
      on {sort}
        self{sort: [asc]}
      on {sort: direction}
        self{sort: direction by key: {: x} x}
      on {sort by key: do f}
        self{sort: [asc] by key: f}
      on {sort: direction by key: do f}
        direction{:
          on {asc}
            self{sort by: {left: l right: r} f{:l}{order: f{: r}}}
          on {desc}
            self{sort by: {left: l right: r} f{:r}{order: f{: l}}}
        }
      on {sort by: do f}
        if length <= 1 then return self end
        let out := array{from: 0 to: length}
        private{sort: out by: f lo: 0 hi: length - 1}
        return VecImpl{array: out length: length}
    ]
]

export let Vec := [
  on {}
    VecImpl{array: Array{} length: 0}
  on {pop: var vec}
    let res := vec{pop}
    set vec := res{most}
    return res{last}
]

let HM := [
  on {empty}
    HM{entry: [empty] children: Option{none}}
  on {init children}
    var cs := Vec{}
    Control{times: 32 do: {}
      set cs{push: HM{empty}}
    }
    cs

  on {entry: entry children: children} [
    on {key: k hash: hash}
      entry{:
        on {empty} ()
        on {key: key value: value}
          if key = k then
            return Option{some: value}
          end
      }
      children{:
        on {some: children}
          let next := children{at: hash & 31}
          return next{key: k hash: hash >> 5}
        on {none}
          return Option{none}
      }

    on {entry: e hash: hash}
      entry{:
        on {empty}
          return HM{entry: e children: children}
        on {key: key value: value}
          if e{key} = key then
            return HM{entry: e children: children}
          end  
      }
      let cs := children{:
        on {none} HM{init children}
        on {some: cs} cs
      }
      let next := cs{at: hash & 31}
      let inserted := next{entry: e hash: hash >> 5}
      let next_cs := cs{at: hash & 31 value: inserted}
      HM{entry: entry children: Option{some: next_cs}}

    on {remove: k hash: hash}
      entry{:
        on {empty} ()
        on {key: key value: __}
          if k = key then
            return HM{entry: [empty] children: children}
          end
      }
      let cs := children{:
        on {none}
          return self
        on {some: cs}
          cs
      }
      let next := cs{at: hash & 31}
      let removed := next{remove: k hash: hash >> 5}
      let next_cs := cs{at: hash & 31 value: removed}
      HM{entry: entry children: Option{some: next_cs}}

    on {size}
      let this_node := entry{:
        on {empty} 0
        else 1
      }
      children{:
        on {none} this_node
        on {some: cs}
          cs{into: this_node fold: {: item into: sum}
            item{size} + sum
          }
      }
  ]
]

export let HashMap := [
  on {}
    HashMap{state: HM{empty}}
  on {state: state} [
    on {key: k}
      state{key: k hash: k{hash}}
    on {key: k value: v}
      let next_state := state{entry: [key: k value: v] hash: k{hash}}
      HashMap{state: next_state}
    on {remove: k}
      let next_state := state{remove: k hash: k{hash}}
      HashMap{state: next_state}
    on {size}
      state{size}
  ]
]

export let Range := [
  on {}
    Range{from: 0 to: 0}
  on {from: range_start to: range_end} [
    on {from}
      range_start
    on {from: value}
      Range{from: value to: range_end}
    on {to}
      range_end
    on {to: value}
      Range{from: range_start to: value}
    on {size}
      if range_end >= range_start then range_end - range_start else 0 end
    on {is superset: other}
      (range_start <= other{from}) && (other{to} <= range_end)
    on {has: value}
      (range_start <= value) && (value < range_end)
    
    on {&: other} {intersection: other}
      let next_start := range_start{max: other{from}}
      let next_end := range_end{min: other{to}}
      Range{from: next_start to: next_end}
  ]
]

