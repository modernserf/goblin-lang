import [_Assert_ _Array_ _Panic_ _Log_ _File_] := "native"
export let Assert := Assert
export let Array := Array
export let Panic := Panic
export let Log := Log
export let File := File

import [_debug_] := "native"
export let Debug := [
  on {: value} debug{: value}
]

import [_true_ _false_] := "native"
export let Bool := [
  on {true} true
  on {false} false
]
export let [_true_ _false_] := Bool

import [String: string] := "native"
export let String := [
  on {from char code: code}
    string{from char code: code}
  on {newline} 
    string{from char code: 10}
  on {tab} 
    string{from char code: 9}
]

import [_bigint_] := "native"
export let BigInt := [
  on {: value}
    bigint{: value}
]

import [_Ord_] := "core/ord"
export let Ord := Ord

import [_Option_] := "core/option"
export let Option := Option 

import [_Result_] := "core/result"
export let Result := Result

import [_Control_] := "core/control"
export let Control := Control

import [_Iter_] := "core/iter"
export let Iter := Iter

import [_Vec_] := "core/vec"
export let Vec := Vec

import [Cell: cell] := "native"
export let Cell := [
  on {: value} 
    let instance := cell{: value}
    return [
      on {}
        instance{get}
      on {: next}
        instance{set: next}
        self
      on {->: do f}
        let prev := instance{get}
        let next := f{: prev}
        instance{set: next}
        self
    ]
]

let HM := [
  on {empty}
    HM{entry: [empty] children: Option{none}}
  on {init children}
    var cs := Vec{}
    Control{times: 32 do: {}
      set cs{push: HM{empty}}
    }
    cs

  on {entry: entry children: children} [
    on {key: k hash: hash}
      entry{:
        on {empty} ()
        on {key: key value: value}
          if key = k then
            return Option{some: value}
          end
      }
      children{:
        on {some: children}
          let next := children{at: hash & 31}
          return next{key: k hash: hash >> 5}
        on {none}
          return Option{none}
      }

    on {entry: e hash: hash}
      entry{:
        on {empty}
          return HM{entry: e children: children}
        on {key: key value: value}
          if e{key} = key then
            return HM{entry: e children: children}
          end  
      }
      let cs := children{:
        on {none} HM{init children}
        on {some: cs} cs
      }
      let next := cs{at: hash & 31}
      let inserted := next{entry: e hash: hash >> 5}
      let next_cs := cs{at: hash & 31 value: inserted}
      HM{entry: entry children: Option{some: next_cs}}

    on {remove: k hash: hash}
      entry{:
        on {empty} ()
        on {key: key value: __}
          if k = key then
            return HM{entry: [empty] children: children}
          end
      }
      let cs := children{:
        on {none}
          return self
        on {some: cs}
          cs
      }
      let next := cs{at: hash & 31}
      let removed := next{remove: k hash: hash >> 5}
      let next_cs := cs{at: hash & 31 value: removed}
      HM{entry: entry children: Option{some: next_cs}}

    on {size}
      let this_node := entry{:
        on {empty} 0
        else 1
      }
      children{:
        on {none} this_node
        on {some: cs}
          cs{into: this_node fold: {: item into: sum}
            item{size} + sum
          }
      }
  ]
]

export let HashMap := [
  on {}
    HashMap{state: HM{empty}}
  on {state: state} [
    on {key: k}
      state{key: k hash: k{hash}}
    on {key: k value: v}
      let next_state := state{entry: [key: k value: v] hash: k{hash}}
      HashMap{state: next_state}
    on {remove: k}
      let next_state := state{remove: k hash: k{hash}}
      HashMap{state: next_state}
    on {size}
      state{size}
  ]
]

export let HashSet := [
  on {}
    HashSet{state: HM{empty}}
  on {state: state} [
    on {has: k}
      state{key: k hash: k{hash}}{is some}
    on {add: k}
      let next_state := state{entry: [key: k value: ()] hash: k{hash}}
      HashSet{state: next_state}
    on {remove: k}
      let next_state := state{remove: k hash: k{hash}}
      HashSet{state: next_state}
    on {size}
      state{size}
  ]
]

let b0 := BigInt{: 0}
let b1 := BigInt{: 1}
let BitSetImpl := [
  on {: value} [
    on {to BigInt}
      value
    on {add: num}
      BitSetImpl{: value | (b1 << BigInt{: num})}
    on {has: num}
      value & (b1 << BigInt{: num}) != b0
    on {&: other}
      BitSetImpl{: value & other{to BigInt}}
    on {|: other}
      BitSetImpl{: value | other{to BigInt}}
    on {size}
      value{popcount}
    on {to Vec}
      var vec := Vec{}
      var bits := value
      var i := 0
      # TODO: unroll this loop
      Control{loop: {}
        if bits = b0 then 
          return vec 
        end
        if (bits & b1) = b1 then 
          set vec{push: i} 
        end
        set i{+: 1}
        set bits{>>: b1}
      }
  ]
]
export let BitSet := [
  on {} 
    BitSetImpl{: BigInt{: 0}}
]

