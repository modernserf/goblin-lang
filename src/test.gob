import [
  _Cell_
  _Assert_
  _Bool_
] := "core"

# strings
let str := "Hello, world!"
Assert{
  received: str 
  expected: "Hello, world!"
}

# bools
Assert{
  received: "Hello" = "Hello"
  expected: Bool{true}
}

Assert{
  received: "Hello" = "Goodbye"
  expected: Bool{false}
}

# numbers, operators
Assert{
  received: 1 + 2
  expected: 3
}

Assert{
  received: 2 + 3 * 4
  expected: 20
}

Assert{
  received: 2 + (3 * 4)
  expected: 14
}

Assert{
  received: do 2 - 1 end
  expected: 1
}

Assert{
  received: do 2; - 1 end
  expected: -1
}

Assert{
  received: 1 = 1
  expected: Bool{true}
}

Assert{
  received: 1 = 2
  expected: Bool{false}
}


# locals
let x := 1
Assert{received: x expected: 1}

# objects
let x := [
  on {} 1
  on {foo} 2
  on {bar: arg} arg
  on {_baz_} baz
]
let bar := 3
Assert{
  received: x{} + x{foo} + x{_bar_} + x{baz: 4}
  expected: 10
}

# frames
let bar := 2
let x := [foo: 1 _bar_]
Assert{
  received: x{foo} + x{bar}
  expected: 3
}

# destructuring
let [x: foo y: [_a_ _b_]] := [x: 1 y: [a: 2 b: 3]]
Assert{
  received: foo + a + b
  expected: 6
}

let p := [
  {add: [x: x1 y: y1] to: [x: x2 y: y2]}
    [x: x1 + x2 y: y1 + y2]
]
let result := p{add: [x: 1 y: 1] to: [x: 2 y: 2]}

Assert{
  received: result{y}
  expected: 3
}

# pattern matching
let foo := [some: 1]
let bar := [none]
let pattern := [
  on {some: x} x
  on {none} 10
]

Assert{
  received: foo{:pattern} + bar{:pattern}
  expected: 11
}

let empty := []
let result := empty{:
  on {} 1
  on {other} 2
  else 3
}

Assert{
  received: result
  expected: 1
}

let result := empty{:
  else 3
}
Assert{
  received: result
  expected: 3
}

# instances
let x := 1
let obj := [
  on {ival} x
]
Assert{
  received: obj{ival}
  expected: 1
}

let obj := [
  on {x} 1
  on {y} self{x}
]
Assert{ 
  received: obj{y}
  expected: 1
}

let indirect := [
  on {x} 1
  on {y} indirect{x}
]
Assert{
  received: indirect{y}
  expected: 1
}

# classes
let Point := [
  on {origin}
    Point{x: 0 y: 0}
  on {x: x y: y} [
    on {x} x
    on {y} y
    on {manhattan distance: other}
      (x - other{x}){abs} +
      (y - other{y}){abs}
  ]
]
Assert{
  received: Point{origin}{manhattan distance: Point{x: 1 y: 1}}
  expected: 2
}

let Option := [
  on {some: value} [
    on {map: fn}
      let next := fn{: value}
      Option{some: next}
    on {or default: __}
      value
  ]
  on {none} [
    on {map: fn}
      self
    on {or default: value}
      value
  ]
]
let foo := Option{some: 1}
Assert{
  received: foo{map: [+: 1]}{or default: 10}
  expected: 2
}
let bar := Option{none}
Assert{
  received: bar{map: [+: 1]}{or default: 10}
  expected: 10
}

# deep closures
let val := 1
let obj := [
  {foo} [
    {bar} [
      {baz} val
    ]
  ]
]
Assert{
  received: obj{foo}{bar}{baz}
  expected: 1
}
    
# var & set
var x := 1
let y := x
set x := 2
Assert{
  received: x
  expected: 2
}
Assert{
  received: y
  expected: 1
}

let obj := [
  {inc: var x}
    set x := x + 1
    self
]
var x := 1
var y := x
obj
  {inc: var x}
  {inc: var x}
Assert{
  received: x
  expected: 3
}
Assert{
  received: y
  expected: 1
}

let obj := [
  {foo: x bar: var y}
    set y := x
    self
]
var y := 0
obj{foo: 2 bar: var y}
Assert{
  received: y
  expected: 2
}

let result := do
  let obj := [{get} using{_foo_} foo]

  provide{foo: 1}
  let x := obj{get}
  provide{foo: 2}
  let y := obj{get}
  x + y
end
Assert{
  received: result
  expected: 3 
}

let result := do
  let a := [{get} using{_foo_} foo]
  provide{foo: 3}
  let b := [
    on {pv 1: fn} 
      provide{foo: 1}
      fn{get}
    on {pv 2: fn}
      provide{foo: 2}
      fn{get}
  ]
  b{pv 1: a} + b{pv 2: a} + a{get}
end
Assert{
  received: result
  expected: 6
}

# cell
let a := Cell{: 0}
let b := a
a{set: 1}

Assert{
  received: b{get}
  expected: 1
}

# else
let pattern := [
  on {foo: x} x
  on {bar} 2
  else 3
]

Assert{
  received: pattern{foo: 1}
  expected: 1
}

Assert{
  received: pattern{bar}
  expected: 2
}

Assert{
  received: pattern{something different}
  expected: 3
}

let value := [else 1]{anything}
Assert{received: value; expected: 1}

# return 
let obj := [
  on {method}
    return 1
    2
]

Assert{
  received: obj{method}
  expected: 1
}

# do vars
var x := 1
do
  set x := 2
end
Assert{
  received: x
  expected: 2
}

# nonlocal return
let obj := [
  on {method}
    do 
      return 1
    end
    return 2 
]
Assert{
  received: obj{method}
  expected: 1
}

# do propagation
let List := [
  on {nil} [
    on {map: do __} 
      self
  ]
  on {head: h tail: t} [
    on {map: do f}
      List{
        head: f{: h}
        tail: t{map: f}
      }
  ]
]
let init := List{
  head: 1 
  tail: List{
    head: 2 
    tail: List{nil}
  }
}

let mapped := init{map: {: value} value + 1}

Assert{
  received: mapped
  expected: List{head: 2 tail: List{head: 3 tail: List{nil}}}
}

# defer
let cell := Cell{: 0}
let foo := [
  on {: do b}
    defer
      cell{update: [+: 1]}
    end
    b{}
    "foo"
]

let bar := [
  on {a} 
    foo{: {} 
      "bar a"
    }
  on {b}
    foo{: {}
      return "bar b"
    }
]

let res := bar{a}
Assert{received: res        expected: "foo"}
Assert{received: cell{get}  expected: 1}

let res := bar{b}
Assert{received: res        expected: "bar b"}
Assert{received: cell{get}  expected: 2}

# loops
let loop := [
  on {: do f}
    f{:
      on {break}
        return
    }
    loop{: f}
]

var i := 0
loop{: {: do l}
  (i = 10){:
    on {true} 
      l{break}
    on {false}
      ()
  }
  set i := i + 1
}

Assert{received: i expected: 10}